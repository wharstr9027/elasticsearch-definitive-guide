[[version-control]]
=== 处理冲突

当使用 `index` API 更新文档 ((("conflicts", "dealing with")))，我们读到原始文件，更改它，然后重新索引整个文档。 最近的索引请求将胜出：哪一个文档最后被索引就会存储在 Elasticsearch 中。如果其他人同时更改这个文档，他们的更改将丢失。

许多时候这是没有问题的。或许我们的主数据存储是一个关系型数据库，我们只需要将数据复制到 Elasticsearch 中并使其可搜索。或许两个人同时更改相同的文档的几率很小。或许对于我们的业务来说偶尔丢失的更改并不是很严重的问题。

但有时丢失了一个更改就是非常重要的。试想一下，我们使用 Elasticsearch 存储我们网上商城库存的数量，每次我们卖一个小部件的时候，我们在 Elasticsearch 中将库存数量减少。

有一天，管理层决定促销。突然地，我们一秒要卖好几个部件。想象一下，两个 web 程序，并行运行，每一个都同时处理每一个部件的销售，如图<<img-data-lww>>所示。

[[img-data-lww]]
.Consequence of no concurrency control
image::images/elas_0301.png["Consequence of no concurrency control",width="50%",align="center"]

 `web_1` 对 `stock_count` 所做的更改已经丢失，因为 `web_2` 不知道它的 'stock_count` 的拷贝已经过期。结果是，我们会认为拥有的库存多于部件的实际数量，我们就会因为卖给他们并不存在的库存而使客户失望。

更改越频繁，读数据和更新数据的间隙越长，也就越可能丢失更改。

在数据库中的世界中，这两种方法通常被用来确保并发更新时更改不会丢失， ((("pessimistic concurrency control")))((("concurrency control")))：

悲观并发控制::

广泛使用的关系型数据库，这种方法假定有冲突的更改可能发生，因此为了防止冲突阻止其他用户对资源的访问。一个典型的例子是读数据之前锁住行，确保仅仅放置锁的线程能够进行更改该行中的数据。

乐观并发控制::

Elasticsearch 中使用的((("optimistic concurrency control")))这种方法假定冲突是不可能发生的，并且不会阻止正在尝试的操作。然而，如果基本数据在读取和写之间被修改，更新将会失败。然后由应用程序来决定该如何解决冲突。 例如，它可以重新尝试更新，使用刷新数据，或者报告有关情况给用户。

[[optimistic-concurrency-control]]
=== 乐观并发控制

Elasticsearch 是分布式的。当文件((("concurrency control", "optimistic")))创建，更新或删除时，该文件的新版本必须被复制到集群中的其他节点。 Elasticsearch 也是异步和并发的，这意味着这些复制请求被并行发送，并且不是按顺序到达目的地。 Elasticsearch 需要一种方法确保文档的旧版本不会覆盖较新的版本。

当我们以前讨论 `index` ， `GET` 和 `delete` 请求时，我们指出每个文件都有一个 `_version` 版本号，当文档被更改时该版本号会增加。Elasticsearch 使用该 `_version` 版本号来保证更改被应用的正确顺序。如果旧版本的文档在新版本之后到达，它可以被简单地忽略。

我们可以利用 `_version` 版本号来保证((("version number (documents)", "using to avoid conflicts")))应用中相互冲突的更改不会导致数据丢失。我们通过指定希望改变的文档的 `version` 版本号来达到这个目的。 如果该版本不是当前版本号，那么我们的请求将会失败。

让我们创建一个新的博客文章：

[source,js]
--------------------------------------------------
PUT /website/blog/1/_create
{
  "title": "My first blog entry",
  "text":  "Just trying this out..."
}
--------------------------------------------------
// SENSE: 030_Data/40_Concurrency.json

该响应体告诉我们，这个新创建的文件 `_version` 版本号是 `1` 。现在假设我们想编辑这个文档：我们加载其数据到 web 表单中，做一些更改，然后保存新的版本。

首先我们检索文档:

[source,js]
--------------------------------------------------
GET /website/blog/1
--------------------------------------------------
// SENSE: 030_Data/40_Concurrency.json

响应体包括相同的 `_version` 版本号 `1` :

[source,js]
--------------------------------------------------
{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "1",
  "_version" : 1,
  "found" :    true,
  "_source" :  {
      "title": "My first blog entry",
      "text":  "Just trying this out..."
  }
}
--------------------------------------------------

现在，当我们试图通过重建文档的索引来保存修改，我们指定 `version` 为更改前生效的版本：

[source,js]
--------------------------------------------------
PUT /website/blog/1?version=1 <1>
{
  "title": "My first blog entry",
  "text":  "Starting to get the hang of this..."
}
--------------------------------------------------
// SENSE: 030_Data/40_Concurrency.json
<1> 如果这个文档的当前 `_version` 在我们的索引中版本是 `1` ，我们希望本次更新成功

该请求成功，并且响应体告诉我们， `_version` 已经增加至 `2` ：

[source,js]
--------------------------------------------------
{
  "_index":   "website",
  "_type":    "blog",
  "_id":      "1",
  "_version": 2
  "created":  false
}
--------------------------------------------------
// SENSE: 030_Data/40_Concurrency.json

但是，如果我们重新运行相同的索引请求，仍旧指定 `version=1` ，Elasticsearch 返回 `409 Conflict` HTTP响应码，和一个响应体如下所示：

[source,js]
--------------------------------------------------
{
   "error": {
      "root_cause": [
         {
            "type": "version_conflict_engine_exception",
            "reason": "[blog][1]: version conflict, current [2], provided [1]",
            "index": "website",
            "shard": "3"
         }
      ],
      "type": "version_conflict_engine_exception",
      "reason": "[blog][1]: version conflict, current [2], provided [1]",
      "index": "website",
      "shard": "3"
   },
   "status": 409
}
--------------------------------------------------
// SENSE: 030_Data/40_Concurrency.json


这告诉我们在 Elasticsearch 中这个文档的当前 `_version` 版本号是 `2` , 但是我们指定的更新版本号为 `1` .

我们现在怎么做取决于我们的应用需求。我们可以告诉用户说别人已经更改了文档，并且在再次保存之前查看这些更改项。可替换地，在以前的 `stock_count` 情况下，我们可以检索到最新的文档并应用这些更改。

所有的 API ，无论是更新或删除一个文档，都会接受 `version` 参数，这允许你在代码中使用乐观的并发控制，是非常有意义的。

==== 使用来自外部系统的版本

一个常见的设置是使用其它数据库作为主要的数据存储，使用 Elasticsearch 做数据检索，((("version number (documents)", "using an external version number")))((("external version numbers"))) 这意味着主数据库的所有更改发生时都需要被拷贝到 Elasticsearch ，如果多个进程负责这一数据同步，你可能遇到类似于先前描述的并发问题。

如果你的主数据库已经有了版本号 --或一个能作为版本号的字段值比如 `timestamp` --那么你就可以在 Elasticsearch 中通过加 `version_type=external` 到查询串的方式重用这些相同的版本号，((("query strings", "version_type=external")))版本号必须是大于零的整数，且小于 `9.2E+18` --在 Java 中的 `long` 正数值。

外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同，Elasticsearch 核查当前 `_version` 是否少于指定的版本，而不是检查该当前 `_version` 是否和请求中指定的版本号相同。如果请求成功时，外部的版本号被存储为文档的新 `_version` 。

外部版本号不仅在索引和删除请求是需要指定，而且在创建新文档时也需要指定。

例如，要创建一个新的具有外部版本号 `5` 的博客文章，我们可以做到以下几点：

[source,js]
--------------------------------------------------
PUT /website/blog/2?version=5&version_type=external
{
  "title": "My first external blog entry",
  "text":  "Starting to get the hang of this..."
}
--------------------------------------------------
// SENSE: 030_Data/40_External_versions.json

在这个响应中，我们能看到当前的 `_version` 版本号是 `5` :

[source,js]
--------------------------------------------------
{
  "_index":   "website",
  "_type":    "blog",
  "_id":      "2",
  "_version": 5,
  "created":  true
}
--------------------------------------------------

现在我们更新这个文档，指定一个新的 `version` 版本号是 `10` :

[source,js]
--------------------------------------------------
PUT /website/blog/2?version=10&version_type=external
{
  "title": "My first external blog entry",
  "text":  "This is a piece of cake..."
}
--------------------------------------------------
// SENSE: 030_Data/40_External_versions.json

请求成功并将当前 `_version` 设为 `10` :

[source,js]
--------------------------------------------------
{
  "_index":   "website",
  "_type":    "blog",
  "_id":      "2",
  "_version": 10,
  "created":  false
}
--------------------------------------------------

如果你要重新运行此请求时，它会失败，并返回像我们以前看到的同样的冲突错误，因为指定的外部版本号不能比 Elasticsearch 当前版本更高。

=== 检索多个文档

Elasticsearch 的检索速度很快，它甚至能更快。((("documents", "retrieving multiple")))将多个请求合并成一个，避免单独处理每个请求花费的网络时延和开销。如果你需要从 Elasticsearch 检索很多文档，那么将这些检索请求放在一个请求中，使用 _multi-get_ 或者  `mget` API((("mget (multi-get) API")))来实现，而不是一个文档一个文档的请求，那么就会更快得到结果。

该  `mget` API带有一个 `docs` 数组作为参数，每个((("docs array", "in request")))元素包含需要检索文档的元数据，包括 `_index` ,  `_type` , 和  `_id` ，如果你想检索一个或者多个特定的字段，那么你可以通过 `_source` 参数来指定这些字段的名字：

[source,js]
--------------------------------------------------
GET /_mget
{
   "docs" : [
      {
         "_index" : "website",
         "_type" :  "blog",
         "_id" :    2
      },
      {
         "_index" : "website",
         "_type" :  "pageviews",
         "_id" :    1,
         "_source": "views"
      }
   ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json

该响应体也包含一个 `docs` 数组((("docs array", "in response body"))),这个数组包含一系列的文档，这些文档的顺序和请求时的顺序相同。这些响应都和使用单个<<get-doc,`get` request>>请求所得到的响应体相同：

[source,js]
--------------------------------------------------
{
   "docs" : [
      {
         "_index" :   "website",
         "_id" :      "2",
         "_type" :    "blog",
         "found" :    true,
         "_source" : {
            "text" :  "This is a piece of cake...",
            "title" : "My first external blog entry"
         },
         "_version" : 10
      },
      {
         "_index" :   "website",
         "_id" :      "1",
         "_type" :    "pageviews",
         "found" :    true,
         "_version" : 2,
         "_source" : {
            "views" : 2
         }
      }
   ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json
 
如果想检索的数据都在相同的 `_index` 中（甚至相同的 `_type` 中），则可以在 URL 中指定默认的 `/_index` 或者默认的  `/_index/_type` 。

你仍然可以在单个请求中覆盖这些值：

[source,js]
--------------------------------------------------
GET /website/blog/_mget
{
   "docs" : [
      { "_id" : 2 },
      { "_type" : "pageviews", "_id" :   1 }
   ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json

事实上，如果所有文档的 `_index` 和 `_type` 都是相同的，你可以只传一个 `ids` 数组，而不是整个 `docs` 数组：

[source,js]
--------------------------------------------------
GET /website/blog/_mget
{
   "ids" : [ "2", "1" ]
}
--------------------------------------------------

注意，我们请求的第二个文档是不存在的。我们指定类型为 `blog` ，但是文档 ID `1` 的类型是 `pageviews` ，这个不存在将在响应体中被报告：

[source,js]
--------------------------------------------------
{
  "docs" : [
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "2",
      "_version" : 10,
      "found" :    true,
      "_source" : {
        "title":   "My first external blog entry",
        "text":    "This is a piece of cake..."
      }
    },
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "1",
      "found" :    false  <1>
    }
  ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json
<1> 未找到该文档.

事实上第二个文档没有找到，并没有影响第一个文档的检索。每个文档都是单独索引和报告的。

[注意事项]
====
即使有一个文档没有找到，前一个请求的 HTTP 状态码仍然是 `200` ，事实上，即使请求的文档都没有找到，那么它的状态码依然是 `200` 。-- 因为 `mget` 请求本身已经成功执行。为了确定单个文档查找的成功与失败，你需要核查 `found` 标志((("found flag")))。 
====
